#!/bin/python3

import wx
import numpy as np
import datetime
import sys
import os

# First dnf install python3-ephem
import ephem

wsize = ( 400, 300 )
temp_file = "/u1/Projects/ESP8266/Projects/tmon/logs/temp_log99"

timer_delay = 1000    # milliseconds

# ----------------------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------------------

# Take an ephem time in ephem format (UTC) and
# return a time string in local time
def utc_to_local_str ( utc ) :
    #tz = 7 - 12
    #local = utc- datetime.timedelta(hours=tz)
    local = ephem.localtime(utc)
    return local.strftime ( "%H:%M:%S" )

# Here is a function to get sunrise/sunset times via the "ephem" package.
# another option would be to use the "astroplan" package,
# Astroplan is an "astropy affiliated" package for the planning of
# astronomical observing from Cornell University.
#
# A bonus tip from my buddy Tim is as follows:
# for date/time stuff i often use astropy.time to do the parsing and format
#  translating. provides a higher level interface than datetime.

def get_sunrise_ephem () :
    # It seems peculiar that it wants the lat/long as strings,
    # but it most definitely does.
    obs = ephem.Observer()
    obs.lat = '32.2226'
    obs.long = '-110.9747'
    obs.date = datetime.datetime.utcnow()

    sun = ephem.Sun(obs)

    # These are UTC in ephem date format
    sr_utc = obs.previous_rising(sun)
    ss_utc = obs.next_setting(sun)

    sr = utc_to_local_str(sr_utc)
    ss = utc_to_local_str(ss_utc)

    return sr, ss

# ----------------------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------------------

class Temp_Data () :

    def __init__ ( self, file ) :
        self.file = file

        self.last_size = 0
        self.info = {}

    def new_data ( self ) :

        new_size = os.path.getsize ( self.file )

        if new_size != self.last_size :
            self.last_size = new_size
            return True
        else :
            return False


    # We do read the entire file, but it goes fast enough
    def read_data ( self, xyz ) :
        f = open ( self.file, "r" )
        data = []

        start = xyz.strftime('%m-%d-%Y')

        # skip until we see the first line we want
        for line in f:
            if line.startswith ( start ) :
                data.append ( line.rstrip() )
                break

        # read the rest to EOF, skipping trassh lines
        for line in f:
            if line[0].isdigit() :
                data.append ( line.rstrip() )

        return data

    # A data line looks like the following.
    #   04-07-2017 17:19:02 18 0 144 308 874
    # We need this to feed to numpy datetime
    #   x = np.datetime64('2019-08-19T20:05:02')
    # So, we just need to strip off the year and move
    # it to the front
    def mk_dt64 ( self, d, t ) :
        dw = d.split ( '-' )
        dd = dw[2] + '-' + dw[0] + '-' + dw[1]
        time_string = dd + "T" + t
        #print ( time_string )
        return np.datetime64 ( time_string )

    def conv_data ( self, data ) :
        yy = []
        xx = []
        for l in data :
            w = l.split()
            xx.append ( self.mk_dt64 ( w[0], w[1] ) )
            yy.append ( float(w[6])/10.0 )
            last_hum = float(w[4])/10.0

        y = np.array ( yy )
        #xx = np.arange ( 0.0, len(yy)*1.0, 1.0 )
        return ( xx, y, last_hum )

    def get_prior ( self ) :

        search = self.xx[-1] - np.timedelta64(1,'D')
        #print ('search: {}, {}'.format(search, self.xx[0]))

        if self.num_days == 1 :
            return prior_24 ( search )

        for i in range(len(self.xx)):
            if self.xx[i] >= search :
                return self.yy[i]

        # This should never happen
        # (but it did until we added prior_24()
        return self.yy[0]

    # This is used to gather 48 hours of data so we
    # can find the correct "prior" data from 24 hours ago
    # when we only have the current 24 hours displayed

    def prior_24 ( self, search ) :

        today = datetime.date.today()

        # In this particular case (getting 48 hours of data)
        # this actually is yesterday
        yesterday = today - datetime.timedelta(days=1)

        d48 = self.read_data ( yesterday )
        x48, y48, h48 = self.conv_data ( d48 )
        #print ( "First 48: ", x48[0] )

        for i in range(len(x48)):
            if x48[i] >= search :
                return y48[i]

        # should never happen
        return y48[0]

    def gather_data ( self ) :

            d = self.read_data ( self.start_time )
            # print ( len(d) )

            # We don't need battery data
            # to plot, just the current value
            w = d[-1].split()
            self.battery = float(w[3]) / 100.0

            # humidity data is just discarded
            #  except for displaying current value
            self.xx, self.yy, self.hh = self.conv_data ( d )

    def set_data_range ( self, ndays ) :

            self.num_days = ndays

            today = datetime.date.today()
            self.start_time = today - datetime.timedelta(days=ndays-1)

    def get_info ( self ) :

            prior = self.get_prior ()
            hi = np.amax ( self.yy )
            lo = np.amin ( self.yy )

            # We really only need to recalculate these
            #  when the day rolls over.
            sr, ss = get_sunrise_ephem ()
            self.info['sunrise'] = sr
            self.info['sunset'] = ss

            self.info['today'] = str(self.yy[-1])
            self.info['prior'] = str(prior)
            self.info['hum'] = str(self.hh)
            self.info['high'] = str(hi)
            self.info['low'] = str(lo)
            self.info['battery'] = str(self.battery)

            return self.info

# -----------------------------------------------------------------------------
# -----------------------------------------------------------------------------

# The left panel has the graph
class Left_Panel ( wx.Panel ) :
        def __init__ ( self, parent, data ) :
            wx.Panel.__init__ ( self, parent )
            self.data = data
            self.SetBackgroundColour ( wx.RED )

        # Called by timer (or button)
        def update ( self ) :
            pass

# The right panel has text information and two useless buttons
class Right_Panel ( wx.Panel ) :
        def __init__ ( self, parent, data ) :
            wx.Panel.__init__ ( self, parent )
            self.data = data
            self.SetBackgroundColour ( wx.GREEN )

            rsz = wx.BoxSizer ( wx.VERTICAL )
            self.SetSizer ( rsz )

#            Radiobutton(f1r, text="24 hour", variable=self.radio_var, value=1, command=self.radio_sel).pack()
#            Radiobutton(f1r, text="48 hour", variable=self.radio_var, value=2, command=self.radio_sel).pack()
#            Radiobutton(f1r, text="72 hour", variable=self.radio_var, value=3, command=self.radio_sel).pack()
#            Radiobutton(f1r, text="week", variable=self.radio_var, value=7, command=self.radio_sel).pack()

            bup = wx.Panel ( self, -1 )
            self.b_up = wx.Button ( bup, wx.ID_ANY, "Update")
            self.b_up.Bind ( wx.EVT_BUTTON, self.onUpdate )
            self.b_ex = wx.Button ( bup, wx.ID_ANY, "Exit")
            self.b_ex.Bind ( wx.EVT_BUTTON, self.onExit )
            bus = wx.BoxSizer ( wx.HORIZONTAL )
            bus.Add ( self.b_up, 1, wx.EXPAND )
            bus.Add ( self.b_ex, 1, wx.EXPAND )
            bup.SetSizer ( bus )
            rsz.Add ( bup, 1, wx.EXPAND )

            self.t_cur_date = wx.StaticText ( self, wx.ID_ANY, "-A-")
            rsz.Add ( self.t_cur_date, 1, wx.EXPAND )
            self.t_cur_time = wx.StaticText ( self, wx.ID_ANY, "---")
            rsz.Add ( self.t_cur_time, 1, wx.EXPAND )
            self.t_prior_temp = wx.StaticText ( self, wx.ID_ANY, "---")
            rsz.Add ( self.t_prior_temp, 1, wx.EXPAND )
            self.t_cur_temp = wx.StaticText ( self, wx.ID_ANY, "---")
            rsz.Add ( self.t_cur_temp, 1, wx.EXPAND )
            self.t_cur_hum = wx.StaticText ( self, wx.ID_ANY, "---")
            rsz.Add ( self.t_cur_hum, 1, wx.EXPAND )

            self.t_sunrise = wx.StaticText ( self, wx.ID_ANY, "---")
            rsz.Add ( self.t_sunrise, 1, wx.EXPAND )
            self.t_sunset = wx.StaticText ( self, wx.ID_ANY, "---")
            rsz.Add ( self.t_sunset, 1, wx.EXPAND )
            self.t_high = wx.StaticText ( self, wx.ID_ANY, "---")
            rsz.Add ( self.t_high, 1, wx.EXPAND )
            self.t_low = wx.StaticText ( self, wx.ID_ANY, "---")
            rsz.Add ( self.t_low, 1, wx.EXPAND )
            self.t_battery = wx.StaticText ( self, wx.ID_ANY, "-Z-")
            rsz.Add ( self.t_battery, 1, wx.EXPAND )

        # Called by timer (or button)
        def update ( self, new_data ) :

            dt_now = datetime.datetime.now()
            # dt_now = datetime.datetime.today()
            #print ( dt_now )

            self.t_cur_date.SetLabel ( dt_now.strftime( "%B %d %Y") )
            self.t_cur_time.SetLabel ( dt_now.strftime("%H:%M:%S") )

            if ( not new_data ) :
                return

            info = self.data.get_info()

            self.t_cur_temp.SetLabel ( " Today: " + info['today'] + "F" )
            self.t_prior_temp.SetLabel ( "Yesterday: " + info['prior'] + "F" )
            self.t_cur_hum.SetLabel ( info['hum'] + " %" )

            self.t_sunrise.SetLabel ( "Sunrise: " + info['sunrise'] )
            self.t_sunset.SetLabel ( "Sunset: " + info['sunset'] )

            self.t_high.SetLabel ( info['high'] + " high" )
            self.t_low.SetLabel ( info['low'] + " low" )

            self.t_battery.SetLabel ( "Battery: " + info['battery'] )

        # Tkinter was always a pain in the ass wanting you
        # to call a destroy method and spewing out weird messages
        # whatever you did. wxPython just works nicely if you do this.
        def onExit ( self, event ) :
            sys.exit ()

        def onUpdate ( self, event ) :
            self.update ()


class Temp_Frame (wx.Frame):
 
        def __init__ ( self, parent, title, data ):
            wx.Frame.__init__(self, None, wx.ID_ANY, title, size=wsize )
            #top = wx.Frame.__init__(self, None, wx.ID_ANY, title, pos=(a,b), size=wsize )

            self.data = data
            self.lpanel = Left_Panel ( self, data )
            self.rpanel = Right_Panel ( self, data )

            sz = wx.BoxSizer ( wx.HORIZONTAL )
            sz.Add ( self.lpanel, 1, wx.EXPAND )
            sz.Add ( self.rpanel, 1, wx.EXPAND )

            self.SetSizer ( sz )

            self.timer = wx.Timer ( self )
            self.Bind ( wx.EVT_TIMER, self.timer_update, self.timer )
            self.timer.Start ( timer_delay )

        def timer_update ( self, event ) :
            print ( "Tick" )
            if data.new_data () :
                self.lpanel.update ()
                self.rpanel.update ( True )
            else:
                self.rpanel.update ( False )

class Temp_GUI ( wx.App ):
        def __init__ ( self, data ) :
            wx.App.__init__(self)
            frame = Temp_Frame ( None, "Temp Plotter", data )
            self.SetTopWindow ( frame )
            frame.Show ( True )


data = Temp_Data ( temp_file )
data.set_data_range ( 2 )
data.gather_data ()

app = Temp_GUI ( data )
app.MainLoop()

# THE END
